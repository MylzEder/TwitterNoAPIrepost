const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

async function login() {
  const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: null,
    timeout: 0, // Set the timeout to 0 for no timeout limit
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  const page = await browser.newPage();
  const hashtags = await readHashtagsFromFile('hashtags.txt');
  await page.goto('https://twitter.com/login');

  console.log('Please wait 80 seconds to log in...');

  // You have 80 seconds to log in
  await page.waitForTimeout(80000);

  const screenshotsFolderPath = path.join(__dirname, 'screenshots');
  fs.mkdirSync(screenshotsFolderPath, { recursive: true });

  let counter = 0; // Counter to limit the number of iterations
  let shouldTerminate = false; // Variable to track termination status

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  // Handle user input
  rl.on('line', (input) => {
    if (input.toLowerCase() === 'end') {
      shouldTerminate = true;
    }
  });

  while (counter < 10 && !shouldTerminate) { // Adjust the number of iterations as needed
    try {
      const shuffledHashtags = shuffleArray(hashtags); // Shuffle the array of hashtags

      // Loop to search and retweet
      for (const hashtag of shuffledHashtags) { // Iterate through shuffled hashtags
        // Search for the hashtag
        await page.goto(`https://twitter.com/search?q=${encodeURIComponent(`#${hashtag}`)}&src=typed_query&f=top`);
        await page.screenshot({ path: path.join(screenshotsFolderPath, `search_${hashtag}.png`) });

        // Wait for the tweets to load
        await page.waitForSelector('div[data-testid="tweet"]', { visible: true });
        await page.screenshot({ path: path.join(screenshotsFolderPath, `tweets_${hashtag}.png`) });

        // Get the list of tweets
        const tweets = await page.$$('div[data-testid="tweet"]');

        // Choose a random tweet index from the top 30
        const randomTweetIndex = getRandomInt(0, Math.min(tweets.length, 30));

        // Capture a screenshot of the chosen tweet
        const chosenTweet = tweets[randomTweetIndex];
        await chosenTweet.screenshot({ path: path.join(screenshotsFolderPath, `chosen_tweet_${hashtag}.png`) });

        // Retweet the chosen tweet
        await chosenTweet.hover();
        await chosenTweet.click('div[data-testid="retweet"]');
        await page.screenshot({ path: path.join(screenshotsFolderPath, `retweet_${hashtag}.png`) });

        // Wait for the retweet menu to appear
        await page.waitForSelector('div[data-testid="retweetConfirm"]', { visible: true });

        // Retweet the tweet
        const retweetButton = await page.$('div[data-testid="retweetConfirm"]');
        await retweetButton.click();

        console.log(`Retweeted a tweet with the hashtag #${hashtag}`);

      // Capture a screenshot before initiating the next loop
      await page.screenshot({ path: path.join(screenshotsFolderPath, `loop_${counter}.png`) });

      if (shouldTerminate) {
        break; // Break out of the loop if termination is requested
      }
    }
    counter++; // Increment the counter
  
  } catch (error) {
      console.error('An error occurred:', error);
    }
  }

  rl.close(); // Close the readline interface

  // Close the browser after breaking the loop
  await browser.close();
}
function readHashtagsFromFile(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) {
        console.error(`Error reading hashtags from file: ${err}`);
        reject([]);
      } else {
        const hashtags = data.split('\n').map((line) => line.trim()).filter((line) => line !== '');
        resolve(hashtags);
      }
    });
  });
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}

login();